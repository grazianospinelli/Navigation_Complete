Per installare le APP in fase di sviluppo sul mobile bisogna attivare la modalità sviluppatore.
Dal menù Impostazioni->Informazioni sul Dispositivo 
Fare 7 volte TAP sulla voce Numero di build -> questo attiva la modalità Sviluppatore
Su Impostazioni->Opzioni Sviluppatore->Abilitare Debug USB

Sul PC:
Avviato Powershell come amministratore
Installazione Chocolatey: gestore pacchetti windows
Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

Installazione node(che contiene il gestore pacchetti npm, python e java development kit)
choco install -y nodejs.install python2 jdk8

npm install -g react-native-cli

installazione Android Studio
Impostazione variabile di ambiente utente ANDROID_HOME: C:\Users\graziano.spinelli\AppData\Local\Android\Sdk

Installazione da Android Studio -> Tools -> SDK

Android 8.0 (Oreo) ->
Android SDK Platform 26
Google APIs Intel x86 Atom_64 System Image

Impostato sul Cell USB x trasferimento file, Attivato sul cell USB Debugging da Impostazioni->Sistema->Opzioni Sviluppatore, collegato tramite USB, controllato il collegamento con:
C:\users\utente\appdata\Local\Android\sdk\platform-tools\adb devices

Su linux adb server deve essere lanciato da root per vedere i dispositivi:
sudo adb kill-server
sudo adb start-server

Lanciata la creazione di una nuova applicazione con:
react-native init NewProject

cd C:\Users\graziano.spinelli\NewProject
Lanciare in un terminale Amministratore il Metro Bundler (gira sulla porta 8081) dalla cartella project con:
react-native start --reset-cache
Attendere il messaggio:
Loading dependency graph, done.

In un altro terminale:
cd C:\Users\graziano.spinelli\NewProject
react-native run-android

L'applicazione sul telefono non parte.
Per risolvere parte del problema lanciare sul PC di sviluppo:
adb.exe reverse tcp:8081 tcp:8081 

Sulla macchina di sviluppo la porta 8081 è occupata allora lanciamo Metro Bundler sulla porta 8088, sempre stando nella cartella Progetto:
react-native start --reset-cache --port=8088

sull'altro terminale:
adb.exe reverse tcp:8088 tcp:8088
react-native run-android

Bisogna configurare la nuova porta anche sull'app nel telefono:
mentre l'applicazione nel telefono è aperta bisogna shackerare il telefono.
Nel menù che compare scegliere: Debugging -> Debug server host & port for device
Inserire: localhost:8088

Fare il Reload dal menù.

Una volta disconnesso il cellulare, per ripristinare la connessione la volta successiva, 
bisogna avere il server JS Metro Bundler attivo in un terminale amministratore e in un altro terminale lanciare:
adb.exe reverse tcp:8088 tcp:8088

Per l'installazione di nuove librerie il Metro Bundler deve essere disattivato e i file in edit tutti chiusi,
altrimenti l'installazione non va a buon fine.
Ogni volta che si installano nuove librerie nella App
- disinstallare dal Cellulare
- Lanciare nel Terminale Amministratore: 
  react-native start --reset-cache --port=8088
- Lanciare nel terminale utente, nella cartella progetto: 
  adb.exe reverse tcp:8088 tcp:8088
  react-native run-android
- Riconfigurare l'app sul cellulare con localhost:8088 in Debugging -> Debug server host & port for device

se non funziona più con le nuove versioni di NodeJS il comando react-native start correggere il file di Metro come da:
https://stackoverflow.com/questions/58117377/react-native-start-giving-invalid-regular-expression-invalid-error
__________________________________________________________________________________________

DISINSTALLARE LIBRERIA DA PROGETTO REACT-Native

1. If it is a library based only on javascript, than you can just run npm uninstall --save package_name or npm uninstall --save-dev package_name
2. If you've installed a library with native content that requires linking, and you've linked it with rnpm then you can do: rnpm unlink package_name then follow step 1
__________________________________________________________________________________________

JSX - a syntax for embedding XML within JavaScript.
Many frameworks use a special templating language which lets you embed code inside markup language. 
In React, this is reversed. JSX lets you write your markup language inside code. 
It looks like HTML on the web, except instead of web things like <div> or <span>, you use React components. 
In this case, <Text> is a built-in component that just displays some text and View is like the <div> or <span>.

import React, { Component } from 'react';
import { Text, View } from 'react-native';

export default class HelloWorldApp extends Component {
  render() {
    return (
      <View>
        <Text>Hello world!</Text>
      </View>
    );
  }
}

this code is defining HelloWorldApp, a new Component. When you're building a React Native app, you'll be making new components a lot. Anything you see on the screen is some sort of component. A component can be pretty simple - the only thing that's required is a render function.

Most components can be customized when they are created, with different parameters. These creation parameters are called props. 

one basic React Native component is the Image. When you create an image, you can use a prop named source to control what image it shows.

let pic = {
      uri: 'https://cinepop.com.br/wp-content/uploads/2017/10/thor4_1-750x380.jpg'
};
return (
      <Image source={pic} style={{width: 193, height: 290}}/>
);

{pic} is surrounded by braces, to embed the variable pic into JSX. You can put any JavaScript expression inside braces in JSX.

There are two types of data that control a component: props and state. props are set by the parent and they are fixed throughout the lifetime of a component. For data that is going to change, we have to use state.
The state is mutable while props are immutable. This means that state can be updated in the future while props cannot be updated.

In general, you should initialize state in the constructor, and then call setState when you want to change it.
When setState is called, the App will re-render its Component.
You can also use a state container like Redux or Mobx to control your data flow. In that case you would use Redux or Mobx to modify your state rather than calling setState directly.

With React Native, you don't use a special language or syntax for defining styles. You just style your application using JavaScript. All of the core components accept a prop named style. The style names and values usually match how CSS works on the web
StyleSheet.create define several styles in one place:

<Text style={styles.bigblue}>just bigblue</Text>

const styles = StyleSheet.create({
  bigblue: {
    color: 'blue',
    fontWeight: 'bold',
    fontSize: 30,
  },
});

The simplest way to set the dimensions of a component is by adding a fixed width and height to style
<View>
        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
        <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />
</View>

_______________________________________________________________________________

ES6 ci offre numerose feature interessanti. Ne elenco solo alcune tra quelle che considero più utili:

- Classi: finalmente viene introdotto il concetto di classe che consente di introdurre la programmazione orientata agli oggetti nel codice JavaScript; ne faremo uso scrivendo componenti React ereditando una classe della libreria (Component).
- Variabili in scope locali: grazie alla parola chiave let possiamo dichiarare variabili che siano locali all’interno del blocco di codice in cui sono dichiarati, per intenderci quello delimitato da parentesi graffe { e }, restringendo quindi la visibilità dello scope rispetto a quelli disponibili nel classico JavaScript quando si utilizza la parola chiave var, ovvero quello globale e quello locale alla funzione.
- Funzioni lambda: grazie all’operatore => possiamo creare funzioni lambda come avviene già in molti altri linguaggi, rendendo il codice più sintetico ed essenziale.
- Moduli: la suddivisione del codice in moduli consente di creare ambiti dai quali è possibile esportare tipi affinché siano visibili all’esterno del modulo corrente, ossia accessibili da altri moduli, dai quali è invece possibile importare dei tipi. Faremo uso di questa funzionalità per esportare componenti React dai nostri script importando la classe base fornita dalla libreria React, dalla quale si deve ereditare per creare un nuovo componente. Questa feature è essenziale per tool di pacchettizzazione come WebPack, che sfrutta questa sintassi per determinare le dipendenze tra i moduli e assemblare il codice opportunamente.

FUNZIONI FRECCIA JAVASCRIPT (Funzioni Lambda)

function square(x) {
  return x * x;
}

Abbiamo la parola chiave function poi le parentesi graffe che raccolgono il corpo della funzione.
In JS possiamo assegnare la nostra funzione ad una variabile con una sintassi di questo tipo:

var square = function(x) {
  return x * x;
};

Vediamo ora come cambia la sintassi con le funzioni freccia:

x => { return x * x }  // block

possiamo scrivere il costrutto anche in altro modo

x => x * x    // omettiamo anche il return

Esempio:
[1,2,3].map(x => 2 * x)  //[ 2, 4, 6 ]

PASSAGGIO DEI PARAMETRI:
() => { ... } // no parameter
x => { ... } // one parameter, an identifier
(x, y) => { ... } // several parameters
__________________________________________________________________________________________

Firebase Cloud Messaging, formerly known as Google Cloud Messaging, is a cross-platform cloud solution for messages and notifications for Android, iOS, and web applications, which currently can be used at no cost. The service is provided by Firebase, a subsidiary of Google.
__________________________________________________________________________________________

Nel file package.json sono elencate tutte le dipendenze dell'applicazione
infatti quando installiamo nuovi componenti con npm, automaticamente compaiono elencati nel file package.
__________________________________________________________________________________________

Per la navigazione tra le schermate dell'applicazione e le icone da utilizzare:

Navigation:
Once we have those five screens set up, we can get the first part of our navigation created — the tab navigation at the bottom of the screen. We’re going to be using the React Navigation library. 
We’ll add a router.js file to the root of our app folder and then install a couple of libraries:

npm install react-navigation --save

e la libreria React Native Elements for icons & such: react-native-elements .

Per gestire le schermate di una App si può usare anche: react-native-router-flux
Nella cartelle della App dare da terminale il comando:
npm install react-native-router-flux --save

Le librerie vanno a finire nella cartella .\node-modules della App e viene aggiornato il file package.json in cui sono raccolte tutte le dipendenze.
L'opzione --save è quella che va ad aggiornare le dipendenze in package.json
__________________________________________________________________________________________

Per implementare una chat installiamo il componente:

npm install react-native-gifted-chat --save
__________________________________________________________________________________________

Per user le prop-types:
npm install --save prop-types

e nel codice:
import PropTypes from 'prop-types';
__________________________________________________________________________________________

Per creare animazioni:

l'animazine viene creata in Adobe After Effects ed implementata nell'App con Lottie.
- Si installa in After Effect Bodymovin:
Bodymovin is a plugin for After Effects that can export animation in json data format for Lottie to use.
- Si installa una libreria per React-Native:
npm i --save lottie-react-native
react-native link lottie-react-native

- Si inserisce in app/build.gradle:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

- Si utilizza nel codice:
import React from 'react';
import LottieView from 'lottie-react-native';

export default class BasicExample extends React.Component {
  render() {
    return (
      <LottieView
        source={require('./animation.json')}
        autoPlay
        loop
      />
    );
  }
}

__________________________________________________________________________________________

FUNZIONI CALLBACK

Le funzioni di un linguaggio di programmazione, come Javascript, consentono di passare come parametro non solo dei valori di tipo variabile o costante, ma anche altre funzioni che prenderanno il nome di funzioni di callback (in italiano funzioni di richiamo). Tali funzioni di callback, in genere (anche dato il nome "callback"), vengono eseguite dopo la routine principale, quindi al termine dell'esecuzione primaria lanciata dalla funzione chiamante.

Lo scopo delle funzioni di callback è quello di consentire a funzioni specifiche di svolgere comiti ulteriori a quelli loro propri, compiti che normalmente non sono noti al momento della scrittura del codice della funzione principale. In pratica si tratta di una tecnica (tipica della programmazione funzionale) grazie alla quale è possibile "espandere" le funzionalità predefinite di un blocco di codice, lasciando allo sviluppatore una maggiore libertà di sviluppo pur mantenendo un elevato grado di "riutilizzo" del codice sorgente.

Guardiamo un basilare esempio sintattico:


function esempio(parametro, callback) {
  
}

La nostra funzione di esempio ha un parametro (potrebbe averne più di uno) e, in ultimo, un altro parametro che chiameremo callback, non perchè sia obbligatorio chiamarlo così, bensì per convenzione. 
La "funzione nella funzione" può essere opzionale o meno, a seconda di come viene controllata, ma in ogni caso sarà richiamata o direttamente definita all'interno del richiamo alla funzione principale, come nel seguente esempio di utilizzo:

function foo() {
  
}

esempio("Valore del parametro...", foo);

oppure:


esempio("Valore del parametro...", function() {
  
});

La nostra prima callback

Facciamo un esempio concreto, programmando una semplice funzione che mostra una alert col nome dell'utente e che consente anche di gestire un'eventuale funzione come ultimo parametro:

function saluto(nome, cognome, callback) {
  alert('Ciao ' + nome + ' ' + cognome);
  if (callback && typeof callback === 'function') callback();
}

Nella nostra funzione di esempio abbiamo tre parametri, due stringhe ("nome" e "cognome") e l'ultimo parameto la funzione di richiamo, opzionale, monitorata attraverso la seguente funzione di controllo:

if (callback && typeof callback === 'function') callback();

Con questo controllo verifichiamo per prima cosa la presenza del parametro "callback", quindi verifichiamo che si tratti di una funzione (utilizzando il comando typeof e verificando che il valore sia function). Se la condizione passa, utilizziamo il nome del parametro aggiungendo le parentesi tonde aperta e chiusa per "trasformare" il parametro in funzione.

Potremmo quindi richiamare la funzione in modo semplice:

saluto('Mario', 'Rossi');

ottenendo semplicemente un alert con scritto:

Ciao Mario Rossi

oppure potremmo creare una funzione di richiamo al suo interno:

saluto('Mario', 'Rossi', function() {
  alert('Sei il benvenuto!');
});

ottenendo come risultato un secondo alert con scritto:

Sei il benvenuto!

In questo modo le due funzioni vengono eseguite in sequenza, nel senso che la nostra callback verrà lanciata non appena terminata l'istruzione primaria che la precede.
Gestire correttamente le temporizzazioni e le chiamate asincrone

Abbiamo detto che lo scopo di una funzione di callback è di essere eseguita, solitamente, dopo la routine principale. In merito a questa osservazione è necessario fare una puntualizzazione: ciò non è sempre vero quando si ha a che fare con delle temporizzazioni o con delle chiamate asincrone (Ajax). Facciamo un esempio.

function temporizzazione(ritardo, callback) {
  window.setTimeout(function() {
    document.write("Scusate il ritardo!");
  }, ritardo);
  if (callback && typeof callback === "function") callback();
}

In questo caso la routine principale è gestita mediante una temporizzazione che prevede un ritardo, pertanto Javascript passerà immediatamente (cioè senza attendere questo ritardo) all'istruzione successiva. In questo caso, quindi, la nostra funzione di cakkback verrà eseguita prima della principale.

Lo sviluppatore che predispone la funzione principale, pertanto, deve avere l'attenzione di gestire correttamente eventuali problemi legati ai tempi di esecuzione delle istruzioni. Per risolvere il problema, ad esempio, sarebbe stato sufficiente inserire il richiamo alla callback direttamente all'interno del metodo setTimeout in questo modo:

function temporizzazione(ritardo, callback) {
  window.setTimeout(function() {
    document.write("Scusate il ritardo!");
    if (callback && typeof callback === "function") callback();
  }, ritardo);
}

Così facendo, infatti, viene ripristinato l'ordine delle cose, in quanto il ritardo di esecuzione riguarderà tanto l'istruzione principale quanto la funzione di callback che, pertanto, tornerà ad essere l'ultimo blocco di esecuzione.

Lo stesso discorso va fatto se si utilizzano chiamate asincrone (Ajax): anche in questo caso, infatti, è opportuno inserire la funzione di calback all'interno del blocco logico che verifica la completa esecuzione ed il successo della chiamata, in caso contrario si potrebbero generare anomalie nel flusso di esecuzione del codice come quelle viste nell'esempio riguardante la cattiva gestione della temporizzazione.

function ajax(risorsa, callback) {
  var requestObj = false;
  if (window.XMLHttpRequest) {
    requestObj = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    requestObj = new ActiveXObject("Microsoft.XMLHTTP");
  }
  requestObj.open("GET", risorsa);
  requestObj.onreadystatechange = function () {
    if (requestObj.readyState == 4 && requestObj.status == 200) {
      alert(requestObj.responseText);
      if (callback && typeof callback === "function") callback();
    }
  }
  requestObj.send(null);
}

Passare il risultato della funzione principale alla funzione di callback

Vediamo infine come passare il valore elaborato dalla prima routine alla nostra funzione di callback in modo tale che quest'ultima possa effettuare operazioni sul risultato della funzione chiamante. Vediamo un esempio:

function somma(a,b,callback) {
  var risultato = (a + b);
  if (callback && typeof callback === "function") {
    risultato = callback(risultato);
  }
  return risultato;  
}

Come potete notare, in questa funzione effettuo il solito controllo per vedere se è stata prevista una funzione di callback ed in caso affermativo ne lancio l'esecuzione passandogli, come parametro, il risultato della routine principale (il risultato della somma di a + b). In questo caso la nostra funzione di callback assegnerà un nuovo valore alla variabile "risultato" alternado, di fatto, il valore di ritorno dalla funzione chiamante.

A questo punto il codice per richiamare la nostra funzione potrebbe essere qualcosa del genere:

var numero = somma(5,3,function(n) {
  return (n*n);
});
document.write(numero);

Con questa semplice funzione di callback prendiamo il valore ottenuto dalla somma di 5+3 (cioè 8) e lo eleviamo al quadrato (facciamo cioè 8x8) ottenendo come risultato 64.

Se la funzione di callbak non viene implementata direttamente nel codice di richiamo ma è esterna, il passaggio di parametri diviene più complicato. Non è possibile, infatti, richiamare direttamente la funzione di callback ma è necessario utilizzare "un intermediario" in questo modo:


function quadrato(n) {
  return (n*n);    
}



var numero = somma(5,3,function(n) {
  return quadrato(n)    
});

________________________________________________________________________________________________________________

Le funzioni callback sono diventate uno dei concetti basi da conoscere se si vuole diventare uno sviluppatore JavaScript. Infatti il linguaggio JavaScript è fortemente basato sul concetto delle funzioni callback.
In concetti di programmazione funzionale ci sono parole come  funzioni anonime e callback.

Prima di parlare di funzioni anonime e callback paliamo di come funziona normalmente una funzione in JavaScript.

Prendiamo questa funzione esempio: (mi dispiace se odiate i gatti :/ ce ne saranno un po’ in questo post)


var mostra_gatti = function(gatto){
    console.log(gatto);
}
mostra_gatti("Romeo");

Come sapete questa funzione prende come input una Stringa e la mostra in output nella console, come farebbe una normale funzione.
Ma il linguaggio JavaScript ci da l’occasione di fare le cose in modo diverso. Infatti in JS anziché aspettare che una funzione finisca di fare il suo lavoro, possiamo usare le funzioni di callback per lavorare in modo asincrono.

Cosa vuol dire lavorare in modo asincrono?

Una funzione asincrona non blocca il nostro codice JS (Browser). In altre parole se eseguiamo una funzione asincrona, questa lavorerà nel background del nostro programma principale. In questo modo possiamo usare funzioni pesanti che possono impiegare tanto tempo (per esempio funzioni AJAX), senza bloccare altri eventi JavaScript.

Adesso immaginiamo di non avere a disposizione una lista dei gatti, dovremo quindi fare una richiesta ad un server per ricevere la lista dei nostri amati felini.

Se immaginiamo di avere una lista molto grande, oppure una lista di gatti generata dinamicamente, la risposta dal server potrebbe impiegare molto tempo per raggiungere il nostro client.

E se la nostra funzione è sincrona, questa come una vera diva, bloccherà tutto finche non ha completato il suo lavoro, mettendo in pausa il resto. Durante questo periodo non sarà possibile alcuna interazione Client – JS

Per evitare che questo accada useremo quindi una funzione asincrona per ottenere la nostra lista.

Cosa sono le funzioni callback in JavaScript?

Le funzioni in JavaScript sono veri e propri Oggetti, questo vuol dire che godono delle stesse proprietà di cui godono le comuni variabili JS. Possiamo quindi passare una funzione come parametro di un’altra funzione.

Per esempio in JavaScript è possibile fare:

var mostra_gatti = function(){…}
var prendi_gatti = function(callback);
prendi_gatti(mostra_gatti); // passiamo prendi_gatti come parametro di mostra_gatti

In questo esempio stiamo chiamando una funzione dichiarata. (Non anonima)

Possiamo fare la stessa cosa utilizzando funzioni anonime, ovvero funzioni dichiarate nello stesso momento in cui vengono utilizzate. Ora vediamo lo stesso programma utilizzando una funzione anonima.

var prendi_gatti = function(callback){…};
prendi_gatti( function(){…} );

Ma se la nostra funzione è in esecuzione in background, Il problema che ci sorge è come facciamo a sapere quando la funzione ha finito ed è pronta per stampare la lista dei gatti?
Come usare le funzioni callback in JavaScript

Ecco dove entrano in gioco le funzioni callback. Infatti quando passiamo una funzione come parametro, possiamo specificare con precisione in che momento vogliamo mandarla in esecuzione.

Nel nostro caso quindi vogliamo mandare in output la nostra lista solamente quando riceviamo una risposta dal server.

Vediamo come: 

// in questo esempio facciamo una richiesta GET al nostro server e eseguiamo la nostra callback quando riceviamo una risposta dal server
var prendi_gatti = function(callback){
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() {
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) // quando riceviamo una risposta
        callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", "www.prendiGatti.com", true); // true per asincrona
    xmlHttp.send(null);
}
var mostra_gatti = function(gatti){
    console.log(gatti);
}
prendi_gatti(mostra_gatti);

oppure utilizzando una funzione anonima:

// in questo esempio facciamo una richiesta GET al nostro server e eseguiamo la nostra callback quando riceviamo una risposta dal server
var prendi_gatti = function(callback){
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() {
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) // quando riceviamo una risposta
        callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", "www.prendiGatti.com", true); // true per asincrona
    xmlHttp.send(null);
}
prendi_gatti(function(gatti){
    console.log(gatti);
});

Se mandiamo in esecuzione questo codice JavaScript otterremo una lista di gatti senza bloccare il browser nel processo.
_____________________________________________________________________________________________

Nella programmazione web, un polyfill (o polyfiller) è del codice scaricabile che fornisce dei servizi che non fanno parte di un browser web. 
Esso implementa tecnologie che uno sviluppatore si aspetta il browser metta a disposizione nativamente, fornendo un ventaglio più uniforme di API. 
Ad esempio, molte caratteristiche di HTML5 non sono supportate da versioni di Internet Explorer precedenti la 8, ma possono essere utilizzate 
dalle pagine web se queste installano un polyfill. 
Webshim e HTML5 Shivs sono concetti correlati. 

_____________________________________________________________________________________________

Analogie tra HTML e React Native

HTML		      React Native
-----------	  ----------------------
div 		      View
img 		      Image
span, p 	    Text
ul/ol, li 	  ListView, child items

_____________________________________________________________________________________________

https://learn.handlebarlabs.com/p/react-native-basics-build-a-currency-converter
User: 

_________________________________________________________________________

Inviare Dati da Mobile React-Native a PHP POST
import FormData from 'FormData';

let formData = new FormData();
formData.append('username', 'Graziano');

let data = {
    method: 'POST',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
    },
    body: formData
}

fetch(api_url, data)
.then(response => response.json())
.then(responseJson => console.log('response:', responseJson))
.catch(error => console.error(error));


I dati che si vuole inviare sono: 
username=Graziano
___________________________________________________________________

INSTALLAZIONE ALGORITMO SHA265
npm install --save react-native-sha256
react-native link

USO:
import { sha256 } from 'react-native-sha256';


sha256("Test").then( hash => {console.log(hash);})

onChangeText= {userPassword => sha256(userPassword.trim()).
  then(userPassword => {this.setState({userPassword});})}

___________________________________________________________________

Installato VSCode
SHORTCUT VSCode:
CTRL+ù        - Commenta automaticamente
TAB+SHIFT     - Back TAB
CTRL+s        - Salva
CTRL+SHIFT+P  - Palette Comandi

Installata Estensione ESLint dentro VSCode
da terminale di VSCode installato globalmente eslint:
npm install -g eslint
Sempre da terminale nella cartella progetto digitiamo:
eslint --init
? How would you like to configure ESLint? Use a popular style guide
? Which style guide do you want to follow? Airbnb (https://github.com/airbnb/javascript)
? Do you use React? Yes
? What format do you want your config file to be in? JavaScript

__________________________________________________________

Redux Form, formik, unstate, reactN per eliminare redux

_____________________________________

GitHub Apps
Personal access tokens
Tokens you have generated that can be used to access the GitHub API:

20777e5c491378f5008f4d8c0a4d5e86a8c45a16

7ef0262c5f294db8a530a991c3e46859
bd3d4befe38185704bf0fc875e9deed6	CarliGist
github access
grazianospinelli - OfficePWD


ISTRUZIONI GIT:

CREATE A BRANCH:
Dalla command palette: git branch

per tornare indietro:
git checkout master

Per andare dinuovo nel branch futuro:
git checkout e selezioniamo il nome del branch futuro

Possiamo pubblicare sul repository remoto in cloud:
git publish

Per aggiungere repository remoto

Creare repository su github, poi: 
git remote add origin https://...
git remote show origin <- funziona se tutto ok
su VS compare la nuvoletta in basso a SX

git push -u origin master # assumendo siamo sul master branch.
oppure clicchiamo la nuvoletta 

Quando ci sono cambiamenti sull'icona git appare un badge numerico

Cliccare sull'icona e decidere quali cambiamenti si vogliono cliccando sul + (stage) oppure sull'undo.

una volta decisi i cambiamenti si puo cliccare sul segno di spunta che è il commit dando un nome al cambiamento.
Il commit registra i cambiamenti sul repository locale, per sincronizzarli in remoto bisogna dare il comando Push
selezionandolo dall'icona Ellipse ...

per tornare indietro click su ... e poi Undo Last Commit

Pull invece scarica in locale i cambiamenti che sono avvenuti sul repository remoto.

Per scaricare repository remoto copiare l'URL da github
Da Command Palette digitare git clone oppure
nella welcome page di VSCode click su "Clone Git Repository.."
Copiare l'URL e specificare la cartella locale
Click su Open Repository.

PER RISOLVERE CONFLITTI DI MERGING:
Per dare precedenza alla versione locale in fase di sync col repository remoto:
git checkout --ours PATH/FILE 
usare il path principale per risolvere tutti i conflitti.

Per forzare le modifiche sul repository remoto, da terminale:

git push https://github.com/grazianospinelli/Navigation_Complete.git --force

Dopo il Force Push per recuperare da un altra copia locale le modifiche sul repository:

git fetch
git reset origin/master --hard

___________________________________________________________________

UTILIZZARE FILE VETTORIALI IN REACT NATIVE

import Svg, {Text} from 'react-native-svg';

...component code

render() {
    return (
        <View style={{flex: 1}}>
            <Svg height={100} width={100}>
                <Text fontFamily="Kingsman" fontSize="22" x="10" y="10">Demo</Text>
            </Svg>
        </View>
    );
}

___________________________________________________________________

Aggiunto nel file android/app/src/main/AndroidManifest.xml nella sezione application:

<application
    android:largeHeap="true"

Per evitare il problema delle immagini Backgroud che spariscono.

aggiunti permessi per utilizzare la fotocamera e il File System del Telefono:
 <uses-permission android:name="android.permission.CAMERA" />
 <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>

___________________________________________________________________

CREAZIONE ANIMAZIONE VETTORIALE PER REACT LOTTIE
scaricato: aescripts + aeplugins zxp installer (setup)
scaricato: bodymovin_v5.4.3

Installato aescripts
Installato bodymovin utilizzando aescripts

Importato in AE file vettoriale.ai oppure .eps
Trascinato file vettoriale nella composizione
Tasto destro su file vettoriale -> Create Shapes from Vector Layer
Raggruppati livelli vettoriali selezionati in un unico gruppo:
Layer -> Group Shapes

Inserito e animato testo nella composizione.
Il livello testo non viene renderizzato correttamente in Bodymovin:
Tasto DX sul livello testo -> Create Shapes from Text

Esportare Animazione con Bodymovin:
Windows -> Extensions -> BodyMovin -> Selezionare Composizione e Cartella -> Render.
___________________________________________________________________

Nel caso di problemi con le dipendenze in fase in installazione librerie,
si potrebbe risolvere la situazione con il comando:
> npm install
e poi riprovare a fare il link della dipendenza problematica.
___________________________________________________________________

Nel caso di problemi con le licenze di Android SDK,
quando risulta che alcune delle licenze non sono accettate, si può eseguire il comando:
> $ANDROID_HOME/tools/bin/sdkmanager --licenses

___________________________________________________________________

npm install react-native-uuid

import uuid from 'react-native-uuid';

Then create some ids ...

// Generate a v1 (time-based) id
uuid.v1(); // -> '6c84fb90-12c4-11e1-840d-7b25c5ee775a'
 
// Generate a v4 (random) id
uuid.v4(); // -> '110ec58a-a0f2-4ac4-8393-c866d813b8d1'

se da errore in fase di bundling:
Error: Unable to resolve module `buffer`

Installare il modulo buffer pure:
npm install buffer --save

react-native-uuid da problemi ------> installare invece uuid 
npm install uuid --save
___________________________________________________________________

LIBRERIA LODASH PER USARE UTILITY throttle.
throttle si usa per assicurasi che la funzione che gli passi non venga chiamata più spesso del numero di millisecondi specificato.
Si usa per la performance nei metodi che renderizzano troppo spesso.

import throttle from 'lodash/throttle';

store.subscribe( 
	throttle(() => {saveState({ todos: store.getState().todos });},
	1000)
);

___________________________________________________________________

LIBRERIE DI GESTIONE FORM:
import { Formik } from "formik";
import { handleTextInput } from "react-native-formik";
import { TextField } from "react-native-material-textfield";
import * as Yup from "yup";

formik serve per gestire il contesto dello stato di un Form, ci dice quando un form è valido oppure sporco
material-textfield offer un campo di input testo in versione material
react-native-formik semplifica l'utilizzo di formik in react-native
Yup è una libreria per facilitare la validazione dei form.
___________________________________________________________________

GESTIONE DELLE DATE:
npm install moment --save 

import moment from "moment";
// Convertire una data in un formato particolare
moment(data).format("DD-MM-YYYY")

Se il comando precedente da errori, bisogna prima validare la data, 
conoscendone il formato, in questo caso MM/DD/YYYY:
moment(data, 'MM/DD/YYYY', true).isValid()
___________________________________________________________________

Installato gestore fotocamera:
npm install react-native-photo-upload --save

che installa anche:
react-native link react-native-image-picker
react-native link react-native-image-resizer
react-native link react-native-fs


Nel file android/app/src/main/AndroidManifest.xml
aggiunti permessi per utilizzare la fotocamera e il File System del Telefono:

 <uses-permission android:name="android.permission.CAMERA" />
 <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>

 Durante la compilazione della App il seguente errore è stato riportato:
  Failed to install the following Android SDK packages as some licences have not been accepted.
  platforms;android-25 Android SDK Platform 25
  To build this project, accept the SDK license agreements and install the missing components using the Android Studio SDK Manager.

Da Android Studio -> SDK Manager (icona in alto a DX) -> Android SDK -> TAB SDK Platform ->
-> Selezionato Android 7.1.1 -> Android SDK Platform 25 -> Apply -> Accettata Licenza

Oppure da Terminale:
cd C:\Users\Graziano\AppData\Local\Android\Sdk\tools\bin
sdkmanager --licenses

___________________________________________________________________

Installata libreria per trasferimento immagini su server:
npm install --save rn-fetch-blob
Impostata la variabile di ambiente:
SET RNFB_ANDROID_PERMISSIONS=true
a seguire dare il solito comando di link della libreria:
react-native link
___________________________________________________________________

VISUALIZZAZIONE CONDIZIONALE:
{this.state.avatarSource === null ? (
              <Text>Select a Photo</Text>
            ) : (
              <Image style={styles.avatar} source={this.state.avatarSource} />
            )}
OPPURE
{this.state.videoSource && (
          <Text style={{ margin: 8, textAlign: 'center' }}> {this.state.videoSource} </Text>
)}
___________________________________________________________________

Nel file index.js di react-native-photo-upload sono state inserite le seguenti modifiche:

nel metodo render:
<TouchableOpacity style={{flex: 0, width: 150, height: 150, marginTop: 200  }} 

Tra le opzioni iniziali, inserite modifiche ai 2 attributi di ImagePicker.showImagePicker:
options = {
    title: this.props.photoPickerTitle || 'Select Photo',
    takePhotoButtonTitle: 'Scatta una foto',
    chooseFromLibraryButtonTitle: 'Scegli dalla Galleria',

___________________________________________________________________

DIFFERENZE TRA COMPONENT E PURECOMPONENT

The major difference between React.PureComponent and React.Component is PureComponent does a shallow comparison on state change. 
It means that when comparing scalar values it compares their values, 
but when comparing objects it compares only references. It helps to improve the performance of the app.
You should go for React.PureComponent when you can satisfy any of the below conditions.

    State/Props should be an immutable object
    State/Props should not have a hierarchy
    You should call forceUpdate when data changes

If you are using React.PureComponent you should make sure all child components are also pure.
    is there any performance impact in using React.component that we may consider going for React.PureComponent?
Yes, it will increase your app performance (because of shallow comparison)
    I am guessing shouldComponentUpdate() of Purecomponent performs only shallow comparisons . If this is the case can' t the said method used for deeper comparisons?
You guessed it correctly. You could use it if you satisfy any of the conditions I mentioned above.
    "Furthermore, React.PureComponent's shouldComponentUpdate() skips prop updates for the whole component subtree" - Does this mean that prop changes are ignored?
Yes, prop changes will be ignored If it couldn't find difference in shallow comparison.
___________________________________________________________________

PER AGGIUNGERE NUOVI FONT:

- partendo dalla cartella della app, mettere il font in:
  ./Assets/Fonts/
- Il file package.json deve contenere in coda il codice:
  "rnpm": {
      "assets": [
        "./Assets/Fonts/"
      ]
    }
- Una volta copiato il font in Assets e modificato il file package bisogna effettuare il link:
  >react-native link
  Questo copia il font nella cartella: android/app/src/main/assets/fonts/
  e per IOS aggiorna il file Info.plist
- Per usare i Font nel codice inserire in style:
   TextStyle: {
    fontFamily: "vincHand",
    fontSize: 20
   }
___________________________________________________________________

PER MODIFICARE UNO CARATTERISTICA DI UNO STYLE LASCIANDO TUTTE LE ALTRE INVARIATE:

style={[styles.button, { backgroundColor: Colors.secondary }]}>
___________________________________________________________________

VISUALIZZAZIONE RAPIDA ARRAY:

const VisualArray = (props) => {
    return (
        <View>{props.myarray.map((elem, i) => <Text key={i}>{elem}</Text>)}</View>
    );
}

render() {
    <VisualArray myarray={this.state.array01} />
}
___________________________________________________________________

Installati:
npm install react-native-deck-swiper --save

npm install react-native-view-overflow --save
react-native link react-native-view-overflow

npm install react-native-card-flip --save

___________________________________________________________________

GENERARE ARRAY DI NUMERI:

function * range (start, end) {
  for (let i = start; i <= end; i++) {
    yield i
  }
}

Nello stato:
this.state = {
      cards: [...range(1, 10)],      
};

___________________________________________________________________

USARE IL GRADIENTE:
import LinearGradient from 'react-native-linear-gradient';
Fuori dal Metodo Render definire funzione:
get gradient () {
    return (
        <LinearGradient
          colors={[Colors.background1, Colors.background2]}
          startPoint={{ x: 1, y: 0 }}
          endPoint={{ x: 0, y: 1 }}
          style={styles.gradient}
        />
    );
}
Dentro render, dopo la view container, richiamarla come:
{ this.gradient }
E negli stili scrivere:
gradient: {
    ...StyleSheet.absoluteFillObject,
  },

___________________________________________________________________

Per visualizzare velocemente tutto il vettore di dati scaricati dal server:
<ScrollView>
  <Text>{JSON.stringify(this.state.dataSource, null, 2)}</Text>
</ScrollView> 
___________________________________________________________________



